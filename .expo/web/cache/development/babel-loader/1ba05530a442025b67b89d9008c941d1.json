{"ast":null,"code":"'use strict';\n\nvar RNFSManager = require('react-native').NativeModules.RNFSManager;\n\nvar NativeAppEventEmitter = require('react-native').NativeAppEventEmitter;\n\nvar DeviceEventEmitter = require('react-native').DeviceEventEmitter;\n\nvar base64 = require('base-64');\n\nvar utf8 = require('utf8');\n\nvar RNFSFileTypeRegular = RNFSManager.RNFSFileTypeRegular;\nvar RNFSFileTypeDirectory = RNFSManager.RNFSFileTypeDirectory;\nvar jobId = 0;\n\nvar getJobId = function getJobId() {\n  jobId += 1;\n  return jobId;\n};\n\nvar RNFS = {\n  mkdir: function mkdir(filepath) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return RNFSManager.mkdir(filepath, options).then(function () {\n      return void 0;\n    });\n  },\n  moveFile: function moveFile(filepath, destPath) {\n    return RNFSManager.moveFile(filepath, destPath).then(function () {\n      return void 0;\n    });\n  },\n  copyFile: function copyFile(filepath, destPath) {\n    return RNFSManager.copyFile(filepath, destPath).then(function () {\n      return void 0;\n    });\n  },\n  pathForBundle: function pathForBundle(bundleNamed) {\n    return RNFSManager.pathForBundle(bundleNamed);\n  },\n  getFSInfo: function getFSInfo() {\n    return RNFSManager.getFSInfo();\n  },\n  unlink: function unlink(filepath) {\n    return RNFSManager.unlink(filepath).then(function () {\n      return void 0;\n    });\n  },\n  exists: function exists(filepath) {\n    return RNFSManager.exists(filepath);\n  },\n  stopDownload: function stopDownload(jobId) {\n    RNFSManager.stopDownload(jobId);\n  },\n  stopUpload: function stopUpload(jobId) {\n    RNFSManager.stopUpload(jobId);\n  },\n  readDir: function readDir(dirpath) {\n    return RNFSManager.readDir(dirpath).then(function (files) {\n      return files.map(function (file) {\n        return {\n          name: file.name,\n          path: file.path,\n          size: file.size,\n          isFile: function isFile() {\n            return file.type === RNFSFileTypeRegular;\n          },\n          isDirectory: function isDirectory() {\n            return file.type === RNFSFileTypeDirectory;\n          }\n        };\n      });\n    });\n  },\n  readdir: function readdir(dirpath) {\n    return RNFS.readDir(dirpath).then(function (files) {\n      return files.map(function (file) {\n        return file.name;\n      });\n    });\n  },\n  stat: function stat(filepath) {\n    return RNFSManager.stat(filepath).then(function (result) {\n      return {\n        'ctime': new Date(result.ctime * 1000),\n        'mtime': new Date(result.mtime * 1000),\n        'size': result.size,\n        'mode': result.mode,\n        isFile: function isFile() {\n          return result.type === RNFSFileTypeRegular;\n        },\n        isDirectory: function isDirectory() {\n          return result.type === RNFSFileTypeDirectory;\n        }\n      };\n    });\n  },\n  readFile: function readFile(filepath, encodingOrOptions) {\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    return RNFSManager.readFile(filepath).then(function (b64) {\n      var contents;\n\n      if (options.encoding === 'utf8') {\n        contents = utf8.decode(base64.decode(b64));\n      } else if (options.encoding === 'ascii') {\n        contents = base64.decode(b64);\n      } else if (options.encoding === 'base64') {\n        contents = b64;\n      } else {\n        throw new Error('Invalid encoding type \"' + String(options.encoding) + '\"');\n      }\n\n      return contents;\n    });\n  },\n  writeFile: function writeFile(filepath, contents, encodingOrOptions) {\n    var b64;\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.writeFile(filepath, b64).then(function () {\n      return void 0;\n    });\n  },\n  appendFile: function appendFile(filepath, contents, encodingOrOptions) {\n    var b64;\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.appendFile(filepath, b64);\n  },\n  downloadFile: function downloadFile(options) {\n    if (typeof options !== 'object') throw new Error('downloadFile: Invalid value for argument `options`');\n    if (typeof options.fromUrl !== 'string') throw new Error('downloadFile: Invalid value for property `fromUrl`');\n    if (typeof options.toFile !== 'string') throw new Error('downloadFile: Invalid value for property `toFile`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('downloadFile: Invalid value for property `headers`');\n    if (options.background && typeof options.background !== 'boolean') throw new Error('downloadFile: Invalid value for property `background`');\n    if (options.progressDivider && typeof options.progressDivider !== 'number') throw new Error('downloadFile: Invalid value for property `progressDivider`');\n    var jobId = getJobId();\n    var subscriptions = [];\n\n    if (options.begin) {\n      subscriptions.push(NativeAppEventEmitter.addListener('DownloadBegin-' + jobId, options.begin));\n    }\n\n    if (options.progress) {\n      subscriptions.push(NativeAppEventEmitter.addListener('DownloadProgress-' + jobId, options.progress));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      fromUrl: options.fromUrl,\n      toFile: options.toFile,\n      headers: options.headers || {},\n      background: !!options.background,\n      progressDivider: options.progressDivider || 0\n    };\n    return {\n      jobId: jobId,\n      promise: RNFSManager.downloadFile(bridgeOptions).then(function (res) {\n        subscriptions.forEach(function (sub) {\n          return sub.remove();\n        });\n        return res;\n      })\n    };\n  },\n  uploadFiles: function uploadFiles(options) {\n    if (!RNFSManager.uploadFiles) {\n      return {\n        jobId: -1,\n        promise: Promise.reject(new Error('`uploadFiles` is unsupported on this platform'))\n      };\n    }\n\n    var jobId = getJobId();\n    var subscriptions = [];\n    if (typeof options !== 'object') throw new Error('uploadFiles: Invalid value for argument `options`');\n    if (typeof options.toUrl !== 'string') throw new Error('uploadFiles: Invalid value for property `toUrl`');\n    if (!Array.isArray(options.files)) throw new Error('uploadFiles: Invalid value for property `files`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('uploadFiles: Invalid value for property `headers`');\n    if (options.fields && typeof options.fields !== 'object') throw new Error('uploadFiles: Invalid value for property `fields`');\n    if (options.method && typeof options.method !== 'string') throw new Error('uploadFiles: Invalid value for property `method`');\n\n    if (options.begin) {\n      subscriptions.push(NativeAppEventEmitter.addListener('UploadBegin-' + jobId, options.begin));\n    }\n\n    if (options.beginCallback) {\n      subscriptions.push(NativeAppEventEmitter.addListener('UploadBegin-' + jobId, options.beginCallback));\n    }\n\n    if (options.progress) {\n      subscriptions.push(NativeAppEventEmitter.addListener('UploadProgress-' + jobId, options.progress));\n    }\n\n    if (options.progressCallback) {\n      subscriptions.push(NativeAppEventEmitter.addListener('UploadProgress-' + jobId, options.progressCallback));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      toUrl: options.toUrl,\n      files: options.files,\n      headers: options.headers || {},\n      fields: options.fields || {},\n      method: options.method || 'POST'\n    };\n    return {\n      jobId: jobId,\n      promise: RNFSManager.uploadFiles(bridgeOptions).then(function (res) {\n        subscriptions.forEach(function (sub) {\n          return sub.remove();\n        });\n        return res;\n      })\n    };\n  },\n  MainBundlePath: RNFSManager.RNFSMainBundlePath,\n  CachesDirectoryPath: RNFSManager.RNFSCachesDirectoryPath,\n  DocumentDirectoryPath: RNFSManager.RNFSDocumentDirectoryPath,\n  ExternalDirectoryPath: RNFSManager.RNFSExternalDirectoryPath,\n  ExternalStorageDirectoryPath: RNFSManager.RNFSExternalStorageDirectoryPath,\n  TemporaryDirectoryPath: RNFSManager.RNFSTemporaryDirectoryPath,\n  LibraryDirectoryPath: RNFSManager.RNFSLibraryDirectoryPath,\n  PicturesDirectoryPath: RNFSManager.RNFSPicturesDirectoryPath\n};\nmodule.exports = RNFS;","map":{"version":3,"sources":["C:/React/my-project/node_modules/react-native-fs/FS.common.js"],"names":["RNFSManager","require","NativeModules","NativeAppEventEmitter","DeviceEventEmitter","base64","utf8","RNFSFileTypeRegular","RNFSFileTypeDirectory","jobId","getJobId","RNFS","mkdir","filepath","options","then","moveFile","destPath","copyFile","pathForBundle","bundleNamed","getFSInfo","unlink","exists","stopDownload","stopUpload","readDir","dirpath","files","map","file","name","path","size","isFile","type","isDirectory","readdir","stat","result","Date","ctime","mtime","mode","readFile","encodingOrOptions","encoding","b64","contents","decode","Error","String","writeFile","encode","appendFile","downloadFile","fromUrl","toFile","headers","background","progressDivider","subscriptions","begin","push","addListener","progress","bridgeOptions","promise","res","forEach","sub","remove","uploadFiles","Promise","reject","toUrl","Array","isArray","fields","method","beginCallback","progressCallback","MainBundlePath","RNFSMainBundlePath","CachesDirectoryPath","RNFSCachesDirectoryPath","DocumentDirectoryPath","RNFSDocumentDirectoryPath","ExternalDirectoryPath","RNFSExternalDirectoryPath","ExternalStorageDirectoryPath","RNFSExternalStorageDirectoryPath","TemporaryDirectoryPath","RNFSTemporaryDirectoryPath","LibraryDirectoryPath","RNFSLibraryDirectoryPath","PicturesDirectoryPath","RNFSPicturesDirectoryPath","module","exports"],"mappings":"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","sourcesContent":["/**\n * React Native FS\n * @flow\n */\n\n'use strict';\n\n// This file supports both iOS and Android\n\nvar RNFSManager = require('react-native').NativeModules.RNFSManager;\n\nvar NativeAppEventEmitter = require('react-native').NativeAppEventEmitter;  // iOS\nvar DeviceEventEmitter = require('react-native').DeviceEventEmitter;        // Android\nvar base64 = require('base-64');\nvar utf8 = require('utf8');\n\nvar RNFSFileTypeRegular = RNFSManager.RNFSFileTypeRegular;\nvar RNFSFileTypeDirectory = RNFSManager.RNFSFileTypeDirectory;\n\nvar jobId = 0;\n\nvar getJobId = () => {\n  jobId += 1;\n  return jobId;\n};\n\ntype MkdirOptions = {\n  RNFSURLIsExcludedFromBackupKey?: boolean;\n};\n\ntype ReadDirItem = {\n  name: string;     // The name of the item\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n\ntype StatResult = {\n  name: string;     // The name of the item\n  path: string;     // The absolute path to the item\n  size: string;     // Size in bytes\n  mode: number;     // UNIX file mode\n  isFile: () => boolean;        // Is the file just a file?\n  isDirectory: () => boolean;   // Is the file a directory?\n};\n\ntype Headers = { [name: string]: string };\ntype Fields = { [name: string]: string };\n\ntype DownloadFileOptions = {\n  fromUrl: string;          // URL to download file from\n  toFile: string;           // Local filesystem path to save the file to\n  headers?: Headers;        // An object of headers to be passed to the server\n  background?: boolean;\n  progressDivider?: number;\n  begin?: (res: DownloadBeginCallbackResult) => void;\n  progress?: (res: DownloadProgressCallbackResult) => void;\n};\n\ntype DownloadBeginCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  contentLength: number;  // The total size in bytes of the download resource\n  headers: Headers;       // The HTTP response headers from the server\n};\n\ntype DownloadProgressCallbackResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  contentLength: number;  // The total size in bytes of the download resource\n  bytesWritten: number;   // The number of bytes written to the file so far\n};\n\ntype DownloadResult = {\n  jobId: number;          // The download job ID, required if one wishes to cancel the download. See `stopDownload`.\n  statusCode: number;     // The HTTP status code\n  bytesWritten: number;   // The number of bytes written to the file\n};\n\ntype UploadFileOptions = {\n  toUrl: string;            // URL to upload file to\n  files: UploadFileItem[];  // An array of objects with the file information to be uploaded.\n  headers?: Headers;        // An object of headers to be passed to the server\n  fields?: Fields;          // An object of fields to be passed to the server\n  method?: string;          // Default is 'POST', supports 'POST' and 'PUT'\n  begin?: (res: UploadBeginCallbackResult) => void;\n  progress?: (res: UploadProgressCallbackResult) => void;\n};\n\ntype UploadFileItem = {\n  name: string;       // Name of the file, if not defined then filename is used\n  filename: string;   // Name of file\n  filepath: string;   // Path to file\n  filetype: string;   // The mimetype of the file to be uploaded, if not defined it will get mimetype from `filepath` extension\n};\n\ntype UploadBeginCallbackResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n};\n\ntype UploadProgressCallbackResult = {\n  jobId: number;                      // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  totalBytesExpectedToSend: number;   // The total number of bytes that will be sent to the server\n  totalBytesSent: number;             // The number of bytes sent to the server\n};\n\ntype UploadResult = {\n  jobId: number;        // The upload job ID, required if one wishes to cancel the upload. See `stopUpload`.\n  statusCode: number;   // The HTTP status code\n  headers: Headers;     // The HTTP response headers from the server\n  body: string;         // The HTTP response body\n};\n\ntype FSInfoResult = {\n  totalSpace: number;   // The total amount of storage space on the device (in bytes).\n  freeSpace: number;    // The amount of available storage space on the device (in bytes).\n};\n\nvar RNFS = {\n\n  mkdir(filepath: string, options: MkdirOptions = {}): Promise<void> {\n    return RNFSManager.mkdir(filepath, options).then(() => void 0);\n  },\n\n  moveFile(filepath: string, destPath: string): Promise<void> {\n    return RNFSManager.moveFile(filepath, destPath).then(() => void 0);\n  },\n\n  copyFile(filepath: string, destPath: string): Promise<void> {\n    return RNFSManager.copyFile(filepath, destPath).then(() => void 0);\n  },\n\n  pathForBundle(bundleNamed: string): Promise<string> {\n    return RNFSManager.pathForBundle(bundleNamed);\n  },\n\n  getFSInfo(): Promise<FSInfoResult> {\n    return RNFSManager.getFSInfo();\n  },\n\n  unlink(filepath: string): Promise<void> {\n    return RNFSManager.unlink(filepath).then(() => void 0);\n  },\n\n  exists(filepath: string): Promise<boolean> {\n    return RNFSManager.exists(filepath);\n  },\n\n  stopDownload(jobId: number): void {\n    RNFSManager.stopDownload(jobId);\n  },\n\n  stopUpload(jobId: number): void {\n    RNFSManager.stopUpload(jobId);\n  },\n\n  readDir(dirpath: string): Promise<ReadDirItem[]> {\n    return RNFSManager.readDir(dirpath).then(files => {\n      return files.map(file => ({\n        name: file.name,\n        path: file.path,\n        size: file.size,\n        isFile: () => file.type === RNFSFileTypeRegular,\n        isDirectory: () => file.type === RNFSFileTypeDirectory,\n      }));\n    });\n  },\n\n  // Node style version (lowercase d). Returns just the names\n  readdir(dirpath: string): Promise<string[]> {\n    return RNFS.readDir(dirpath).then(files => {\n      return files.map(file => file.name);\n    });\n  },\n\n  stat(filepath: string): Promise<StatResult> {\n    return RNFSManager.stat(filepath).then((result) => {\n      return {\n        'ctime': new Date(result.ctime * 1000),\n        'mtime': new Date(result.mtime * 1000),\n        'size': result.size,\n        'mode': result.mode,\n        isFile: () => result.type === RNFSFileTypeRegular,\n        isDirectory: () => result.type === RNFSFileTypeDirectory,\n      };\n    });\n  },\n\n  readFile(filepath: string, encodingOrOptions?: any): Promise<string> {\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    return RNFSManager.readFile(filepath).then((b64) => {\n      var contents;\n\n      if (options.encoding === 'utf8') {\n        contents = utf8.decode(base64.decode(b64));\n      } else if (options.encoding === 'ascii') {\n        contents = base64.decode(b64);\n      } else if (options.encoding === 'base64') {\n        contents = b64;\n      } else {\n        throw new Error('Invalid encoding type \"' + String(options.encoding) + '\"');\n      }\n\n      return contents;\n    });\n  },\n\n  writeFile(filepath: string, contents: string, encodingOrOptions?: any): Promise<void> {\n    var b64;\n\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.writeFile(filepath, b64).then(() => void 0);\n  },\n\n  appendFile(filepath: string, contents: string, encodingOrOptions?: any): Promise<void> {\n    var b64;\n\n    var options = {\n      encoding: 'utf8'\n    };\n\n    if (encodingOrOptions) {\n      if (typeof encodingOrOptions === 'string') {\n        options.encoding = encodingOrOptions;\n      } else if (typeof encodingOrOptions === 'object') {\n        options = encodingOrOptions;\n      }\n    }\n\n    if (options.encoding === 'utf8') {\n      b64 = base64.encode(utf8.encode(contents));\n    } else if (options.encoding === 'ascii') {\n      b64 = base64.encode(contents);\n    } else if (options.encoding === 'base64') {\n      b64 = contents;\n    } else {\n      throw new Error('Invalid encoding type \"' + options.encoding + '\"');\n    }\n\n    return RNFSManager.appendFile(filepath, b64);\n  },\n\n  downloadFile(options: DownloadFileOptions): { jobId: number, promise: Promise<DownloadResult> } {\n    if (typeof options !== 'object') throw new Error('downloadFile: Invalid value for argument `options`');\n    if (typeof options.fromUrl !== 'string') throw new Error('downloadFile: Invalid value for property `fromUrl`');\n    if (typeof options.toFile !== 'string') throw new Error('downloadFile: Invalid value for property `toFile`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('downloadFile: Invalid value for property `headers`');\n    if (options.background && typeof options.background !== 'boolean') throw new Error('downloadFile: Invalid value for property `background`');\n    if (options.progressDivider && typeof options.progressDivider !== 'number') throw new Error('downloadFile: Invalid value for property `progressDivider`');\n\n    var jobId = getJobId();\n    var subscriptions = [];\n\n    if (options.begin) {\n      subscriptions.push(NativeAppEventEmitter.addListener('DownloadBegin-' + jobId, options.begin));\n    }\n\n    if (options.progress) {\n      subscriptions.push(NativeAppEventEmitter.addListener('DownloadProgress-' + jobId, options.progress));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      fromUrl: options.fromUrl,\n      toFile: options.toFile,\n      headers: options.headers || {},\n      background: !!options.background,\n      progressDivider: options.progressDivider || 0\n    };\n\n    return {\n      jobId,\n      promise: RNFSManager.downloadFile(bridgeOptions).then(res => {\n        subscriptions.forEach(sub => sub.remove());\n        return res;\n      })\n    };\n  },\n\n  uploadFiles(options: UploadFileOptions): { jobId: number, promise: Promise<UploadResult> } {\n    if (!RNFSManager.uploadFiles) {\n      return {\n        jobId: -1,\n        promise: Promise.reject(new Error('`uploadFiles` is unsupported on this platform'))\n      };\n    }\n\n    var jobId = getJobId();\n    var subscriptions = [];\n\n    if (typeof options !== 'object') throw new Error('uploadFiles: Invalid value for argument `options`');\n    if (typeof options.toUrl !== 'string') throw new Error('uploadFiles: Invalid value for property `toUrl`');\n    if (!Array.isArray(options.files)) throw new Error('uploadFiles: Invalid value for property `files`');\n    if (options.headers && typeof options.headers !== 'object') throw new Error('uploadFiles: Invalid value for property `headers`');\n    if (options.fields && typeof options.fields !== 'object') throw new Error('uploadFiles: Invalid value for property `fields`');\n    if (options.method && typeof options.method !== 'string') throw new Error('uploadFiles: Invalid value for property `method`');\n\n    if (options.begin) {\n      subscriptions.push(NativeAppEventEmitter.addListener('UploadBegin-' + jobId, options.begin));\n    }\n    if (options.beginCallback) {\n      // Deprecated\n      subscriptions.push(NativeAppEventEmitter.addListener('UploadBegin-' + jobId, options.beginCallback));\n    }\n\n    if (options.progress) {\n      subscriptions.push(NativeAppEventEmitter.addListener('UploadProgress-' + jobId, options.progress));\n    }\n    if (options.progressCallback) {\n      // Deprecated\n      subscriptions.push(NativeAppEventEmitter.addListener('UploadProgress-' + jobId, options.progressCallback));\n    }\n\n    var bridgeOptions = {\n      jobId: jobId,\n      toUrl: options.toUrl,\n      files: options.files,\n      headers: options.headers || {},\n      fields: options.fields || {},\n      method: options.method || 'POST'\n    };\n\n    return {\n      jobId,\n      promise: RNFSManager.uploadFiles(bridgeOptions).then(res => {\n        subscriptions.forEach(sub => sub.remove());\n        return res;\n      })\n    };\n  },\n\n  MainBundlePath: RNFSManager.RNFSMainBundlePath,\n  CachesDirectoryPath: RNFSManager.RNFSCachesDirectoryPath,\n  DocumentDirectoryPath: RNFSManager.RNFSDocumentDirectoryPath,\n  ExternalDirectoryPath: RNFSManager.RNFSExternalDirectoryPath,\n  ExternalStorageDirectoryPath: RNFSManager.RNFSExternalStorageDirectoryPath,\n  TemporaryDirectoryPath: RNFSManager.RNFSTemporaryDirectoryPath,\n  LibraryDirectoryPath: RNFSManager.RNFSLibraryDirectoryPath,\n  PicturesDirectoryPath: RNFSManager.RNFSPicturesDirectoryPath\n\n};\n\nmodule.exports = RNFS;\n"]},"metadata":{},"sourceType":"script"}